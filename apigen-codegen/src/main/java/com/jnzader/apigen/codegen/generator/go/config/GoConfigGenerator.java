package com.jnzader.apigen.codegen.generator.go.config;

import com.jnzader.apigen.codegen.generator.api.Feature;
import com.jnzader.apigen.codegen.generator.api.ProjectConfig;
import com.jnzader.apigen.codegen.generator.go.GoTypeMapper;
import com.jnzader.apigen.codegen.model.SqlSchema;
import com.jnzader.apigen.codegen.model.SqlTable;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Generates configuration files for Go/Gin projects.
 *
 * <p>Generates:
 *
 * <ul>
 *   <li>go.mod
 *   <li>main.go
 *   <li>.env.example
 *   <li>Dockerfile
 *   <li>docker-compose.yml
 *   <li>Makefile
 *   <li>README.md
 *   <li>.gitignore
 * </ul>
 */
public class GoConfigGenerator {

    private final String moduleName;
    private final GoTypeMapper typeMapper;

    public GoConfigGenerator(String moduleName) {
        this.moduleName = moduleName;
        this.typeMapper = new GoTypeMapper();
    }

    /**
     * Generates all configuration files.
     *
     * @param schema the SQL schema
     * @param config the project configuration
     * @return map of file paths to content
     */
    public Map<String, String> generate(SqlSchema schema, ProjectConfig config) {
        Map<String, String> files = new LinkedHashMap<>();

        files.put("go.mod", generateGoMod());
        files.put("main.go", generateMainGo(schema));
        files.put(".env.example", generateEnvExample());
        files.put(".env", generateEnvExample());
        files.put(".gitignore", generateGitignore());
        files.put("README.md", generateReadme(schema));
        files.put("Makefile", generateMakefile());

        // Config package
        files.put("internal/config/config.go", generateConfigGo());
        files.put("internal/config/database.go", generateDatabaseGo());

        if (config.isFeatureEnabled(Feature.DOCKER)) {
            files.put("Dockerfile", generateDockerfile());
            files.put("docker-compose.yml", generateDockerCompose());
            files.put(".dockerignore", generateDockerignore());
        }

        return files;
    }

    private String generateGoMod() {
        return """
        module %s

        go 1.23

        require (
        	github.com/gin-gonic/gin v1.10.0
        	github.com/go-playground/validator/v10 v10.26.0
        	github.com/google/uuid v1.6.0
        	github.com/joho/godotenv v1.5.1
        	github.com/shopspring/decimal v1.4.0
        	github.com/swaggo/files v1.0.1
        	github.com/swaggo/gin-swagger v1.6.0
        	github.com/swaggo/swag v1.16.4
        	gorm.io/driver/postgres v1.5.11
        	gorm.io/gorm v1.25.12
        )
        """
                .formatted(moduleName);
    }

    private String generateMainGo(SqlSchema schema) {
        StringBuilder sb = new StringBuilder();

        sb.append("package main\n\n");

        sb.append("import (\n");
        sb.append("\t\"log\"\n");
        sb.append("\t\"os\"\n");
        sb.append("\n");
        sb.append("\t\"").append(moduleName).append("/internal/config\"\n");
        sb.append("\t\"").append(moduleName).append("/internal/handler\"\n");
        sb.append("\t\"").append(moduleName).append("/internal/repository\"\n");
        sb.append("\t\"").append(moduleName).append("/internal/router\"\n");
        sb.append("\t\"").append(moduleName).append("/internal/service\"\n");
        sb.append("\t\"github.com/joho/godotenv\"\n");
        sb.append(")\n\n");

        // Swagger info
        sb.append("// @title           ").append(getProjectName()).append(" API\n");
        sb.append("// @version         1.0\n");
        sb.append("// @description     REST API generated by APiGen\n");
        sb.append("// @host            localhost:8080\n");
        sb.append("// @BasePath        /api/v1\n\n");

        sb.append("func main() {\n");
        sb.append("\t// Load environment variables\n");
        sb.append("\tif err := godotenv.Load(); err != nil {\n");
        sb.append("\t\tlog.Println(\"No .env file found, using environment variables\")\n");
        sb.append("\t}\n\n");

        sb.append("\t// Load configuration\n");
        sb.append("\tcfg := config.Load()\n\n");

        sb.append("\t// Initialize database\n");
        sb.append("\tdb, err := config.NewDatabase(cfg)\n");
        sb.append("\tif err != nil {\n");
        sb.append("\t\tlog.Fatalf(\"Failed to connect to database: %v\", err)\n");
        sb.append("\t}\n\n");

        sb.append("\t// Initialize repositories\n");
        for (SqlTable table : schema.getEntityTables()) {
            String entityName = typeMapper.toExportedName(table.getEntityName());
            String varName = typeMapper.toUnexportedName(entityName) + "Repo";
            sb.append("\t")
                    .append(varName)
                    .append(" := repository.New")
                    .append(entityName)
                    .append("Repository(db)\n");
        }
        sb.append("\n");

        sb.append("\t// Initialize services\n");
        for (SqlTable table : schema.getEntityTables()) {
            String entityName = typeMapper.toExportedName(table.getEntityName());
            String repoVar = typeMapper.toUnexportedName(entityName) + "Repo";
            String svcVar = typeMapper.toUnexportedName(entityName) + "Svc";
            sb.append("\t")
                    .append(svcVar)
                    .append(" := service.New")
                    .append(entityName)
                    .append("Service(")
                    .append(repoVar)
                    .append(")\n");
        }
        sb.append("\n");

        sb.append("\t// Initialize handlers\n");
        sb.append("\thandlers := &router.Handlers{\n");
        for (SqlTable table : schema.getEntityTables()) {
            String entityName = typeMapper.toExportedName(table.getEntityName());
            String svcVar = typeMapper.toUnexportedName(entityName) + "Svc";
            sb.append("\t\t")
                    .append(entityName)
                    .append(": handler.New")
                    .append(entityName)
                    .append("Handler(")
                    .append(svcVar)
                    .append("),\n");
        }
        sb.append("\t}\n\n");

        sb.append("\t// Setup router\n");
        sb.append("\tr := router.SetupRouter(handlers)\n\n");

        sb.append("\t// Start server\n");
        sb.append("\tport := os.Getenv(\"PORT\")\n");
        sb.append("\tif port == \"\" {\n");
        sb.append("\t\tport = \"8080\"\n");
        sb.append("\t}\n\n");

        sb.append("\tlog.Printf(\"Server starting on port %s\", port)\n");
        sb.append("\tif err := r.Run(\":\" + port); err != nil {\n");
        sb.append("\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n");
        sb.append("\t}\n");
        sb.append("}\n");

        return sb.toString();
    }

    private String generateConfigGo() {
        return """
        package config

        import (
        	"os"
        	"strconv"
        )

        // Config holds application configuration.
        type Config struct {
        	Port        string
        	Environment string
        	Database    DatabaseConfig
        }

        // DatabaseConfig holds database configuration.
        type DatabaseConfig struct {
        	Host     string
        	Port     int
        	User     string
        	Password string
        	DBName   string
        	SSLMode  string
        }

        // Load loads configuration from environment variables.
        func Load() *Config {
        	return &Config{
        		Port:        getEnv("PORT", "8080"),
        		Environment: getEnv("ENVIRONMENT", "development"),
        		Database: DatabaseConfig{
        			Host:     getEnv("DB_HOST", "localhost"),
        			Port:     getEnvAsInt("DB_PORT", 5432),
        			User:     getEnv("DB_USER", "postgres"),
        			Password: getEnv("DB_PASSWORD", "postgres"),
        			DBName:   getEnv("DB_NAME", "%s"),
        			SSLMode:  getEnv("DB_SSLMODE", "disable"),
        		},
        	}
        }

        func getEnv(key, defaultValue string) string {
        	if value := os.Getenv(key); value != "" {
        		return value
        	}
        	return defaultValue
        }

        func getEnvAsInt(key string, defaultValue int) int {
        	if value := os.Getenv(key); value != "" {
        		if i, err := strconv.Atoi(value); err == nil {
        			return i
        		}
        	}
        	return defaultValue
        }
        """
                .formatted(toSnakeCase(getProjectName()));
    }

    private String generateDatabaseGo() {
        return """
        package config

        import (
        	"fmt"
        	"log"
        	"time"

        	"%s/internal/models"
        	"gorm.io/driver/postgres"
        	"gorm.io/gorm"
        	"gorm.io/gorm/logger"
        )

        // NewDatabase creates a new database connection.
        func NewDatabase(cfg *Config) (*gorm.DB, error) {
        	dsn := fmt.Sprintf(
        		"host=%%s port=%%d user=%%s password=%%s dbname=%%s sslmode=%%s",
        		cfg.Database.Host,
        		cfg.Database.Port,
        		cfg.Database.User,
        		cfg.Database.Password,
        		cfg.Database.DBName,
        		cfg.Database.SSLMode,
        	)

        	logLevel := logger.Info
        	if cfg.Environment == "production" {
        		logLevel = logger.Warn
        	}

        	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
        		Logger: logger.Default.LogMode(logLevel),
        	})
        	if err != nil {
        		return nil, fmt.Errorf("failed to connect to database: %%w", err)
        	}

        	// Configure connection pool
        	sqlDB, err := db.DB()
        	if err != nil {
        		return nil, fmt.Errorf("failed to get sql.DB: %%w", err)
        	}

        	sqlDB.SetMaxIdleConns(10)
        	sqlDB.SetMaxOpenConns(100)
        	sqlDB.SetConnMaxLifetime(time.Hour)

        	// Auto-migrate models
        	if err := autoMigrate(db); err != nil {
        		return nil, fmt.Errorf("failed to auto-migrate: %%w", err)
        	}

        	log.Println("Database connection established")
        	return db, nil
        }

        func autoMigrate(db *gorm.DB) error {
        	return db.AutoMigrate(
        		// Add your models here
        		&models.BaseModel{},
        	)
        }
        """
                .formatted(moduleName);
    }

    private String generateEnvExample() {
        return """
        # Application
        PORT=8080
        ENVIRONMENT=development

        # Database
        DB_HOST=localhost
        DB_PORT=5432
        DB_USER=postgres
        DB_PASSWORD=postgres
        DB_NAME=%s
        DB_SSLMODE=disable

        # JWT (optional)
        JWT_SECRET=your-secret-key
        JWT_EXPIRATION_HOURS=24
        """
                .formatted(toSnakeCase(getProjectName()));
    }

    private String generateGitignore() {
        return """
        # Binaries
        *.exe
        *.exe~
        *.dll
        *.so
        *.dylib
        /bin/
        /build/

        # Test binary
        *.test

        # Output of go coverage tool
        *.out
        coverage.html

        # Environment files
        .env
        .env.local
        .env.*.local

        # IDE
        .idea/
        .vscode/
        *.swp
        *.swo

        # Vendor (if not using go modules)
        /vendor/

        # OS
        .DS_Store
        Thumbs.db

        # Build artifacts
        /tmp/
        """;
    }

    private String generateReadme(SqlSchema schema) {
        StringBuilder sb = new StringBuilder();
        String projectName = getProjectName();

        sb.append("# ").append(projectName).append("\n\n");
        sb.append("REST API generated by APiGen using Go and Gin framework.\n\n");

        sb.append("## Requirements\n\n");
        sb.append("- Go 1.23+\n");
        sb.append("- PostgreSQL 15+\n");
        sb.append("- Make (optional)\n\n");

        sb.append("## Getting Started\n\n");

        sb.append("### 1. Configure environment\n\n");
        sb.append("```bash\n");
        sb.append("cp .env.example .env\n");
        sb.append("# Edit .env with your database credentials\n");
        sb.append("```\n\n");

        sb.append("### 2. Create database\n\n");
        sb.append("```bash\n");
        sb.append("createdb ").append(toSnakeCase(projectName)).append("\n");
        sb.append("```\n\n");

        sb.append("### 3. Download dependencies\n\n");
        sb.append("```bash\n");
        sb.append("go mod download\n");
        sb.append("```\n\n");

        sb.append("### 4. Generate Swagger documentation\n\n");
        sb.append("```bash\n");
        sb.append("make swagger\n");
        sb.append("# or\n");
        sb.append("swag init\n");
        sb.append("```\n\n");

        sb.append("### 5. Run the application\n\n");
        sb.append("```bash\n");
        sb.append("# Development\n");
        sb.append("make run\n");
        sb.append("# or\n");
        sb.append("go run main.go\n\n");
        sb.append("# Production build\n");
        sb.append("make build\n");
        sb.append("./bin/").append(toSnakeCase(projectName)).append("\n");
        sb.append("```\n\n");

        sb.append("## API Documentation\n\n");
        sb.append("Once the application is running, visit:\n");
        sb.append("- Swagger UI: http://localhost:8080/swagger/index.html\n");
        sb.append("- Health check: http://localhost:8080/health\n\n");

        sb.append("## Available Endpoints\n\n");
        for (SqlTable table : schema.getEntityTables()) {
            String entityName = table.getEntityName();
            String pluralPath = typeMapper.toSnakeCase(typeMapper.pluralize(entityName));
            sb.append("### ").append(entityName).append("\n\n");
            sb.append("| Method | Endpoint | Description |\n");
            sb.append("|--------|----------|-------------|\n");
            sb.append("| GET | `/api/v1/")
                    .append(pluralPath)
                    .append("` | List all with pagination |\n");
            sb.append("| GET | `/api/v1/").append(pluralPath).append("/:id` | Get by ID |\n");
            sb.append("| POST | `/api/v1/").append(pluralPath).append("` | Create new |\n");
            sb.append("| PUT | `/api/v1/").append(pluralPath).append("/:id` | Update |\n");
            sb.append("| DELETE | `/api/v1/")
                    .append(pluralPath)
                    .append("/:id` | Soft delete |\n\n");
        }

        sb.append("## Makefile Commands\n\n");
        sb.append("```bash\n");
        sb.append("make run        # Run the application\n");
        sb.append("make build      # Build the binary\n");
        sb.append("make test       # Run tests\n");
        sb.append("make lint       # Run linter\n");
        sb.append("make swagger    # Generate Swagger docs\n");
        sb.append("make clean      # Clean build artifacts\n");
        sb.append("```\n\n");

        sb.append("## Docker\n\n");
        sb.append("```bash\n");
        sb.append("# Build and run with Docker Compose\n");
        sb.append("docker-compose up -d\n\n");
        sb.append("# Build image only\n");
        sb.append("docker build -t ").append(toSnakeCase(projectName)).append(" .\n");
        sb.append("```\n\n");

        sb.append("## Project Structure\n\n");
        sb.append("```\n");
        sb.append(".\n");
        sb.append("├── main.go                 # Application entry point\n");
        sb.append("├── internal/\n");
        sb.append("│   ├── config/            # Configuration\n");
        sb.append("│   ├── dto/               # Data Transfer Objects\n");
        sb.append("│   ├── handler/           # HTTP handlers\n");
        sb.append("│   ├── models/            # GORM models\n");
        sb.append("│   ├── repository/        # Data access layer\n");
        sb.append("│   ├── router/            # Route definitions\n");
        sb.append("│   └── service/           # Business logic\n");
        sb.append("├── docs/                  # Swagger documentation\n");
        sb.append("├── Dockerfile\n");
        sb.append("└── docker-compose.yml\n");
        sb.append("```\n\n");

        sb.append("## License\n\n");
        sb.append("MIT\n");

        return sb.toString();
    }

    private String generateMakefile() {
        String binaryName = toSnakeCase(getProjectName());
        return """
        .PHONY: run build test lint swagger clean help

        BINARY_NAME=%s
        MAIN_PATH=.

        ## help: Show this help message
        help:
        	@echo "Usage: make [target]"
        	@echo ""
        	@echo "Targets:"
        	@sed -n 's/^##//p' ${MAKEFILE_LIST} | column -t -s ':' | sed -e 's/^/ /'

        ## run: Run the application
        run:
        	go run $(MAIN_PATH)/main.go

        ## build: Build the binary
        build:
        	go build -o bin/$(BINARY_NAME) $(MAIN_PATH)/main.go

        ## test: Run tests
        test:
        	go test -v -race -coverprofile=coverage.out ./...

        ## test-coverage: Run tests and show coverage
        test-coverage: test
        	go tool cover -html=coverage.out -o coverage.html

        ## lint: Run linter
        lint:
        	golangci-lint run ./...

        ## swagger: Generate Swagger documentation
        swagger:
        	swag init

        ## clean: Clean build artifacts
        clean:
        	rm -rf bin/
        	rm -f coverage.out coverage.html

        ## tidy: Tidy go modules
        tidy:
        	go mod tidy

        ## docker-build: Build Docker image
        docker-build:
        	docker build -t $(BINARY_NAME) .

        ## docker-run: Run with Docker Compose
        docker-run:
        	docker-compose up -d

        ## docker-stop: Stop Docker Compose
        docker-stop:
        	docker-compose down
        """
                .formatted(binaryName);
    }

    private String generateDockerfile() {
        String binaryName = toSnakeCase(getProjectName());
        return """
        # Build stage
        FROM golang:1.23-alpine AS builder

        WORKDIR /app

        # Install build dependencies
        RUN apk add --no-cache git

        # Copy go.mod and go.sum
        COPY go.mod go.sum ./
        RUN go mod download

        # Copy source code
        COPY . .

        # Build the binary
        RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o bin/%s main.go

        # Production stage
        FROM alpine:3.21

        WORKDIR /app

        # Install ca-certificates for HTTPS
        RUN apk --no-cache add ca-certificates tzdata

        # Copy binary from builder
        COPY --from=builder /app/bin/%s .

        # Create non-root user
        RUN adduser -D -g '' appuser
        USER appuser

        EXPOSE 8080

        ENTRYPOINT ["./%s"]
        """
                .formatted(binaryName, binaryName, binaryName);
    }

    private String generateDockerCompose() {
        String projectName = toSnakeCase(getProjectName());
        return """
        services:
          app:
            build: .
            container_name: %s-api
            ports:
              - "8080:8080"
            environment:
              - PORT=8080
              - ENVIRONMENT=production
              - DB_HOST=db
              - DB_PORT=5432
              - DB_USER=postgres
              - DB_PASSWORD=postgres
              - DB_NAME=%s
              - DB_SSLMODE=disable
            depends_on:
              db:
                condition: service_healthy
            restart: unless-stopped

          db:
            image: postgres:16-alpine
            container_name: %s-db
            environment:
              - POSTGRES_USER=postgres
              - POSTGRES_PASSWORD=postgres
              - POSTGRES_DB=%s
            volumes:
              - postgres_data:/var/lib/postgresql/data
            ports:
              - "5432:5432"
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U postgres"]
              interval: 10s
              timeout: 5s
              retries: 5
            restart: unless-stopped

        volumes:
          postgres_data:
        """
                .formatted(projectName, projectName, projectName, projectName);
    }

    private String generateDockerignore() {
        return """
        bin/
        tmp/
        *.exe
        *.test
        *.out
        .git
        .gitignore
        .env
        .env.local
        *.md
        .idea
        .vscode
        coverage.out
        coverage.html
        """;
    }

    private String getProjectName() {
        // Extract project name from module name (last part after /)
        int lastSlash = moduleName.lastIndexOf('/');
        if (lastSlash >= 0) {
            return moduleName.substring(lastSlash + 1);
        }
        return moduleName;
    }

    private String toSnakeCase(String name) {
        return name.replaceAll("([a-z])([A-Z])", "$1_$2").replaceAll("-", "_").toLowerCase();
    }
}
